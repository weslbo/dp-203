{
	"name": "Explore a relational data warehouse",
	"properties": {
		"folder": {
			"name": "dp-203/04-Dedicated SQL/08-Demo-Explore a relational data warehouse"
		},
		"content": {
			"query": "/* This exercise is shared with the DP-500 (Azure Data Analyst) curriculum and is available at\n   https://microsoftlearning.github.io/DP-500-Azure-Data-Analyst/Instructions/labs/03-Explore-data-warehouse.html\n\nExplore the data warehouse schema\n=================================\n- Make sure the sqldwh has been resumed\n- View the tables in the database\n\nA relational data warehouse is typically based on a schema that consists of fact and dimension tables. \nThe tables are optimized for analytical queries in which numeric metrics in the fact tables are aggregated \nby attributes of the entities represented by the dimension tables - for example, enabling you to aggregate\nInternet sales revenue by product, customer, date, and so on.\n\nExpand the dbo.FactInternetSales table and its Columns folder to see the columns in this table. \nNote that many of the columns are keys that reference rows in the dimension tables. Others are numeric values\n(measures) for analysis. The keys are used to relate a fact table to one or more dimension tables, \noften in a star schema; in which the fact table is directly related to each dimension table (forming a \nmulti-pointed “star” with the fact table at the center).\n\n*/\n\nselect column_name, data_type from information_schema.columns where table_name = 'FactInternetSales' order by ordinal_position\n\n/*\nView the columns for the dbo.DimPromotion table, and note that it has a unique PromotionKey that uniquely\nidentifies each row in the table. It also has an AlternateKey. Usually, data in a data warehouse has been \nimported from one or more transactional sources. The alternate key reflects the business identifier for the \ninstance of this entity in the source, but a unique numeric surrogate key is usually generated to uniquely \nidentify each row in the data warehouse dimension table. One of the benefits of this approach is that it \nenables the data warehouse to contain multiple instances of the same entity at different points in time \n(for example, records for the same customer reflecting their address at the time an order was placed).\n*/\n\nselect column_name, data_type from information_schema.columns where table_name = 'DimPromotion' order by ordinal_position\n\n/*\nView the columns for the dbo.DimProduct, and note that it contains a ProductSubcategoryKey column, \nwhich references the dbo.DimProductSubcategory table, which in turn contains a ProductCategoryKey \ncolumn that references the dbo.DimProductCategory table. In some cases, dimensions are partially normalized \ninto multiple related tables to allow for different levels of granularity - such as products that can be \ngrouped into subcategories and categories. This results in a simple star being extended to a snowflake schema, \nin which the central fact table is related to a dimension table, which is turn related to further dimension tables.\n*/\n\nselect column_name, data_type from information_schema.columns where table_name = 'DimProduct' order by ordinal_position\nselect column_name, data_type from information_schema.columns where table_name = 'DimProductSubcategory' order by ordinal_position\nselect column_name, data_type from information_schema.columns where table_name = 'DimProductCategory' order by ordinal_position\n\n/*\nView the columns for the dbo.DimDate table, and note that it contains multiple columns that reflect different temporal \nattributes of a date - including the day of week, day of month, month, year, day name, month name, and so on. \nTime dimensions in a data warehouse are usually implemented as a dimension table containing a row for each of \nthe smallest temporal units of granularity (often called the grain of the dimension) by which you want to aggregate \nthe measures in the fact tables. In this case, the lowest grain at which measures can be aggregated is an individual date, \nand the table contains a row for each date from the first to the last date referenced in the data. The attributes in the \nDimDate table enable analysts to aggregate measures based on any date key in the fact table, using a consistent set of \ntemporal attributes (for example, viewing orders by month based on the order date). The FactInternetSales table contains \nthree keys that relate to the DimDate table: OrderDateKey, DueDateKey, and ShipDateKey.\n*/\n\nselect column_name, data_type from information_schema.columns where table_name = 'DimDate' order by ordinal_position\n\n/*\nQuery the data warehouse tables\n===============================\n\nNow that you have explored some of the more important aspects of the data warehouse schema, you’re ready to to query \nthe tables and retrieve some data.\n\n1. Query fact and dimension tables\n----------------------------------\nNumeric values in a relational data warehouse are stored in fact tables with related dimension tables that you can use \nto aggregate the data across multiple attributes. This design means that most queries in a relational data warehouse \ninvolve aggregating and grouping data (using aggregate functions and GROUP BY clauses) across related tables (using JOIN clauses).\n\nThe following query should show the Internet sales totals for each year. This query joins the fact table for Internet sales \nto a time dimension table based on the order date, and aggregates the sales amount measure in the fact table by \nthe calendar month attribute of the dimension table.\n*/\n\nSELECT  d.CalendarYear AS Year,\n        SUM(i.SalesAmount) AS InternetSalesAmount\nFROM FactInternetSales AS i\nJOIN DimDate AS d ON i.OrderDateKey = d.DateKey\nGROUP BY d.CalendarYear\nORDER BY Year;\n\n/*\nModify the query as follows to add the month attribute from the time dimension, and then run the modified query.\nNote that the attributes in the time dimension enable you to aggregate the measures in the fact table at multiple \nhierarchical levels - in this case, year and month. This is a common pattern in data warehouses.\n*/\n\nSELECT  d.CalendarYear AS Year,\n        d.MonthNumberOfYear AS Month,\n        SUM(i.SalesAmount) AS InternetSalesAmount\nFROM FactInternetSales AS i\nJOIN DimDate AS d ON i.OrderDateKey = d.DateKey\nGROUP BY d.CalendarYear, d.MonthNumberOfYear\nORDER BY Year, Month;\n\n/*\nModify the query as follows to remove the month and add a second dimension to the aggregation, and then run \nit to view the results (which show yearly Internet sales totals for each region):\n\nNote that geography is a snowflake dimension that is related to the Internet sales fact table through the customer\ndimension. You therefore need two joins in the query to aggregate Internet sales by geography.\n*/\n\nSELECT  d.CalendarYear AS Year,\n        g.EnglishCountryRegionName AS Region,\n        SUM(i.SalesAmount) AS InternetSalesAmount\nFROM FactInternetSales AS i\nJOIN DimDate AS d ON i.OrderDateKey = d.DateKey\nJOIN DimCustomer AS c ON i.CustomerKey = c.CustomerKey\nJOIN DimGeography AS g ON c.GeographyKey = g.GeographyKey\nGROUP BY d.CalendarYear, g.EnglishCountryRegionName\nORDER BY Year, Region;\n\n/*\nModify and re-run the query to add another snowflake dimension and aggregate the yearly regional sales by product category:\n\nThis time, the snowflake dimension for product category requires three joins to reflect the hierarchical relationship \nbetween products, subcategories, and categories.\n*/\n\nSELECT  d.CalendarYear AS Year,\n        pc.EnglishProductCategoryName AS ProductCategory,\n        g.EnglishCountryRegionName AS Region,\n        SUM(i.SalesAmount) AS InternetSalesAmount\nFROM FactInternetSales AS i\nJOIN DimDate AS d ON i.OrderDateKey = d.DateKey\nJOIN DimCustomer AS c ON i.CustomerKey = c.CustomerKey\nJOIN DimGeography AS g ON c.GeographyKey = g.GeographyKey\nJOIN DimProduct AS p ON i.ProductKey = p.ProductKey\nJOIN DimProductSubcategory AS ps ON p.ProductSubcategoryKey = ps.ProductSubcategoryKey\nJOIN DimProductCategory AS pc ON ps.ProductCategoryKey = pc.ProductCategoryKey\nGROUP BY d.CalendarYear, pc.EnglishProductCategoryName, g.EnglishCountryRegionName\nORDER BY Year, ProductCategory, Region;\n\n/*\n2. Use ranking functions\n------------------------\n\nAnother common requirement when analyzing large volumes of data is to group the data by partitions and determine \nthe rank of each entity in the partition based on a specific metric.\n\nThe following SQL retrieves sales values for 2022 over partitions based on country/region name. Observe the following facts about these results:\n\n- There’s a row for each sales order line item.\n- The rows are organized in partitions based on the geography where the sale was made.\n- The rows within each geographical partition are numbered in order of sales amount (from smallest to highest).\n- For each row, the line item sales amount as well as the regional total and average sales amounts are included.\n*/\n\nSELECT  g.EnglishCountryRegionName AS Region,\n      ROW_NUMBER() OVER(PARTITION BY g.EnglishCountryRegionName\n                        ORDER BY i.SalesAmount ASC) AS RowNumber,\n      i.SalesOrderNumber AS OrderNo,\n      i.SalesOrderLineNumber AS LineItem,\n      i.SalesAmount AS SalesAmount,\n      SUM(i.SalesAmount) OVER(PARTITION BY g.EnglishCountryRegionName) AS RegionTotal,\n      AVG(i.SalesAmount) OVER(PARTITION BY g.EnglishCountryRegionName) AS RegionAverage\nFROM FactInternetSales AS i\nJOIN DimDate AS d ON i.OrderDateKey = d.DateKey\nJOIN DimCustomer AS c ON i.CustomerKey = c.CustomerKey\nJOIN DimGeography AS g ON c.GeographyKey = g.GeographyKey\nWHERE d.CalendarYear = 2022\nORDER BY Region;\n\n/*\nApply windowing functions within a GROUP BY query and rank the cities in each region based on their total sales amount:\n\nObserve the following:\n- The results include a row for each city, grouped by region.\n- The total sales (sum of individual sales amounts) is calculated for each city\n- The regional sales total (the sum of the sum of sales amounts for each city in the region) is calculated based on the regional partition.\n- The rank for each city within its regional partition is calculated by ordering the total sales amount per city in descending order.\n*/\n\nSELECT  g.EnglishCountryRegionName AS Region,\n      g.City,\n      SUM(i.SalesAmount) AS CityTotal,\n      SUM(SUM(i.SalesAmount)) OVER(PARTITION BY g.EnglishCountryRegionName) AS RegionTotal,\n      RANK() OVER(PARTITION BY g.EnglishCountryRegionName\n                  ORDER BY SUM(i.SalesAmount) DESC) AS RegionalRank\nFROM FactInternetSales AS i\nJOIN DimDate AS d ON i.OrderDateKey = d.DateKey\nJOIN DimCustomer AS c ON i.CustomerKey = c.CustomerKey\nJOIN DimGeography AS g ON c.GeographyKey = g.GeographyKey\nGROUP BY g.EnglishCountryRegionName, g.City\nORDER BY Region;\n\n/*\n3. Retrieve an approximate count\n--------------------------------\nWhen exploring very large volumes of data, queries can take significant time and resources to run. Often, data analysis doesn’t \nrequire absolutely precise values - a comparison of approximate values may be sufficient.\n\nThe following SQL code retrieves the number of sales orders for each calendar year:\n\nThen review the output that is returned:\n- On the Results tab under the query, view the order counts for each year.\n- On the Messages tab, view the total execution time for the query.\n\n*/\n\nSELECT d.CalendarYear AS CalendarYear,\n   COUNT(DISTINCT i.SalesOrderNumber) AS Orders\nFROM FactInternetSales AS i\nJOIN DimDate AS d ON i.OrderDateKey = d.DateKey\nGROUP BY d.CalendarYear\nORDER BY CalendarYear;\n\n/*\nNow, return an approximate count for each year. Review the output that is returned:\n- On the Results tab under the query, view the order counts for each year. These should be within 2% of the actual counts retrieved by the previous query.\n- On the Messages tab, view the total execution time for the query. This should be shorter than for the previous query.\n*/\n\nSELECT d.CalendarYear AS CalendarYear,\n   APPROX_COUNT_DISTINCT(i.SalesOrderNumber) AS Orders\nFROM FactInternetSales AS i\nJOIN DimDate AS d ON i.OrderDateKey = d.DateKey\nGROUP BY d.CalendarYear\nORDER BY CalendarYear;\n\n/*\nLet's see if there's a difference in the number we get returned (notice that the following query might not be optimized)\n*/\nSELECT d.CalendarYear AS CalendarYear,\n   COUNT(DISTINCT i.SalesOrderNumber) AS OrdersCount,\n   APPROX_COUNT_DISTINCT(i.SalesOrderNumber) AS OrdersApproxCount\nFROM FactInternetSales AS i\nJOIN DimDate AS d ON i.OrderDateKey = d.DateKey\nGROUP BY d.CalendarYear\nORDER BY CalendarYear\n\n/*\n3. Challenge - Analyze reseller sales\n-------------------------------------\nCreate SQL queries in the script to find the following information based on the FactResellerSales fact table and the dimension tables to which it is related:\n- The total quantity of items sold per fiscal year and quarter.\n- The total quantity of items sold per fiscal year, quarter, and sales territory region associated with the employee who made the sale.\n- The total quantity of items sold per fiscal year, quarter, and sales territory region by product category.\n- The rank of each sales territory per fiscal year based on total sales amount for the year.\n- The approximate number of sales order per year in each sales territory\n*/\n\n-- Items sold by Fiscal Year and Quarter\nSELECT  d.FiscalYear AS FY,\n        d.FiscalQuarter AS FQ,\n        SUM(r.OrderQuantity) AS ItemsSold\nFROM FactResellerSales AS r\nJOIN DimDate AS d ON r.OrderDateKey = d.DateKey\nGROUP BY d.FiscalYear, d.FiscalQuarter\nORDER BY FY, FQ;\n\n\n-- Items sold by Fiscal Year, Quarter, and sales territory region\nSELECT  d.FiscalYear AS FY,\n        d.FiscalQuarter AS FQ,\n        t. SalesTerritoryRegion AS SalesTerritory,\n        SUM(r.OrderQuantity) AS ItemsSold\nFROM FactResellerSales AS r\nJOIN DimDate AS d ON r.OrderDateKey = d.DateKey\nJOIN DimEmployee AS e ON r.EmployeeKey = e.EmployeeKey\nJOIN DimSalesTerritory AS t ON e.SalesTerritoryKey = t.SalesTerritoryKey\nGROUP BY d.FiscalYear, d.FiscalQuarter, t. SalesTerritoryRegion\nORDER BY FY, FQ, SalesTerritory\n\n\n-- Items sold by Fiscal Year, Quarter, sales territory region, and product category\nSELECT  d.FiscalYear AS FY,\n        d.FiscalQuarter AS FQ,\n        t. SalesTerritoryRegion AS SalesTerritory,\n        pc.EnglishProductCategoryName AS ProductCategory,\n        SUM(r.OrderQuantity) AS ItemsSold\nFROM FactResellerSales AS r\nJOIN DimDate AS d ON r.OrderDateKey = d.DateKey\nJOIN DimEmployee AS e ON r.EmployeeKey = e.EmployeeKey\nJOIN DimSalesTerritory AS t ON e.SalesTerritoryKey = t.SalesTerritoryKey\nJOIN DimProduct AS p ON r.ProductKey = p.ProductKey\nJOIN DimProductSubcategory AS ps ON p.ProductSubcategoryKey = ps.ProductSubcategoryKey\nJOIN DimProductCategory AS pc ON ps.ProductCategoryKey = pc.ProductCategoryKey\nGROUP BY d.FiscalYear, d.FiscalQuarter, t. SalesTerritoryRegion, pc.EnglishProductCategoryName\nORDER BY FY, FQ, SalesTerritory, ProductCategory\n\n\n-- Ranked sales territories by year based on total sales amount\nSELECT  d.FiscalYear,\n        t. SalesTerritoryRegion AS SalesTerritory,\n        SUM(s.SalesAmount) AS TerritoryTotal,\n        SUM(SUM(s.SalesAmount)) OVER(PARTITION BY d.FiscalYear) AS YearTotal,\n        RANK() OVER(PARTITION BY d.FiscalYear\n                    ORDER BY SUM(s.SalesAmount) DESC) AS RankForYear\nFROM FactResellerSales AS s\nJOIN DimDate AS d ON s.OrderDateKey = d.DateKey\nJOIN DimEmployee AS e ON s.EmployeeKey = e.EmployeeKey\nJOIN DimSalesTerritory AS t ON e.SalesTerritoryKey = t.SalesTerritoryKey\nGROUP BY d.FiscalYear, t.SalesTerritoryRegion\nORDER BY d.FiscalYear;\n\n-- Approximate number of sales orders per fiscal year by territory\nSELECT  d.FiscalYear,\n        t. SalesTerritoryRegion AS SalesTerritory,\n        APPROX_COUNT_DISTINCT(s.SalesOrderNumber) AS ApproxOrders\nFROM FactResellerSales AS s\nJOIN DimDate AS d ON s.OrderDateKey = d.DateKey\nJOIN DimEmployee AS e ON s.EmployeeKey = e.EmployeeKey\nJOIN DimSalesTerritory AS t ON e.SalesTerritoryKey = t.SalesTerritoryKey\nGROUP BY d.FiscalYear, t.SalesTerritoryRegion\nORDER BY d.FiscalYear, ApproxOrders;",
			"metadata": {
				"language": "sql"
			},
			"currentConnection": {
				"databaseName": "sqldwh",
				"poolName": "sqldwh"
			},
			"resultLimit": -1
		},
		"type": "SqlQuery"
	}
}